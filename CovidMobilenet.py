# -*- coding: utf-8 -*-
"""modeloMobilenet.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Z-o-S7yHz9lJbKd8MV_9667FdHlN-brB

# **Kaggle**
"""

! pip install -q kaggle

from google.colab import files

files.upload()

! mkdir ~/.kaggle

! cp kaggle.json ~/.kaggle/

! chmod 600 ~/.kaggle/kaggle.json

! kaggle datasets list

"""# **Data Loader**"""

import urllib.request
import os
from PIL import Image,ImageStat
import numpy as np
import matplotlib.pyplot as plt

import torchvision
import torch
import torch.nn as nn
from torch.utils.data import  DataLoader
import torchvision.transforms as transforms
import torch.functional as F

!pwd

main_dir = "/content/drive/MyDrive/pulmoes"
os.chdir(main_dir)

!pwd

!ls

import pandas as pd
import glob
import pandas
import numpy as np

def image_loader(img):
  return Image.open(img)

img = image_loader('normal/Normal-50.png')

img.convert('RGB')

img

transform = transforms.Compose([transforms.Resize((50,50)),
                                transforms.ToTensor(),
                                transforms.Normalize((0.5), (0.5))
                                ])

img_tensor = transform(img)

img_tensor.shape

img_tensor.view(1,1,50,50).shape

!ls

"""# **Criação das Classes**"""

for file_names in os.scandir('./'):
    print(file_names)

dir = './'

classes = [d.name for d in os.scandir(dir) if d.is_dir()]

classes

classes.sort()

class_to_idx = {cls_name: i for i, cls_name in enumerate(classes)}

class_to_idx

#dataset = torchvision.datasets.DatasetFolder('./',loader = image_loader,extensions='jpg',transform=transform )

instances = []
for target_class in sorted(class_to_idx.keys()):
        class_index = class_to_idx[target_class]
        target_dir = os.path.join(dir, target_class)
        for root, _, fnames in sorted(os.walk(target_dir, followlinks=True)):
            for fname in sorted(fnames):
                path = os.path.join(root, fname)
                item = path, class_index
                instances.append(item)

instances

"""# **Criação do Data Set**"""

from torch.utils.data import Dataset

from typing import Any,Tuple

class PulmoesDataset(Dataset):
    def __init__(self,dir,transform=None,target_transform=None,loader = None):
        self.main_dir = dir
        self.transform = transform
        self.target_transform = target_transform
        self.classes = [d.name for d in os.scandir(dir) if d.is_dir()]
        self.classes.sort()
        self.class_to_idx = {cls_name: i for i, cls_name in enumerate(self.classes)}
        self.instances = self.make_instances()
        self.loader = loader
        if loader is None:
            self.loader = lambda x: Image.open(x).convert('RGB')

    def make_instances(self):
        instances = []
        for target_class in sorted(self.class_to_idx.keys()):
                class_index = self.class_to_idx[target_class]
                target_dir = os.path.join(self.main_dir, target_class)
                for root, _, fnames in sorted(os.walk(target_dir, followlinks=True)):
                    for fname in sorted(fnames):
                        path = os.path.join(root, fname)
                        item = path, class_index
                        instances.append(item)
        return instances
    def __getitem__(self,index:int) -> Tuple[Any,Any]:
        path, target = self.instances[index] #path, target = atributo classe
        instance = self.loader(path)
        if self.transform is not None:
            instance = self.transform(instance)
        if self.target_transform is not None:
            target = self.target_transform(target)
        return instance,target
    def __len__(self) -> int:
        return len(self.instances)

dataset = PulmoesDataset('./',transform=transform)

len(dataset)

dl = DataLoader(dataset,batch_size=1024)

data,class_att = next(iter(dl))

data.shape

class_att.shape

grid_img = torchvision.utils.make_grid(data,nrow=45)

plt.imshow(grid_img.permute(1,2,0))

"""# **Criação e Ajuste Fino do Modelo Mobilenet v3 Small**"""

model = torchvision.models.mobilenet_v3_small(pretrained=True)

model

####Ajuste fino dos 3 modelos####
model.classifier[3] = nn.Linear(1024,4)

"""# **Split**"""

from sklearn.model_selection import train_test_split
import numpy as np

#Tentei fazer com stratify, mas demorou 1h para executar e retornou o seguinte erro:
#ValueError: only one element tensors can be converted to Python scalars
#como as classes são suficientemente grandes, consegui obter uma boa taxa de aprendizagem mesmo sem stratify
train_idx, temp_idx = train_test_split(np.arange(len(dataset)),test_size=0.3,shuffle=True)

len(train_idx),len(temp_idx)

valid_idx, test_idx = train_test_split(temp_idx,test_size=0.5,shuffle=True)

len(valid_idx),len(test_idx)

valid_idx

#for idx in [train_idx,valid_idx,test_idx]:
#    print(np.unique(dataset[idx],return_counts=True))

bs = 1024
train_sampler = torch.utils.data.SubsetRandomSampler(train_idx)
valid_sampler = torch.utils.data.SubsetRandomSampler(valid_idx)
test_sampler  = torch.utils.data.SubsetRandomSampler(test_idx)

dl_train = torch.utils.data.DataLoader(dataset,batch_size=bs,sampler=train_sampler)
dl_valid = torch.utils.data.DataLoader(dataset,batch_size=bs,sampler=valid_sampler)
dl_test  = torch.utils.data.DataLoader(dataset,batch_size=bs,sampler=test_sampler)

"""# **Otimização**"""

import torch.optim as optim

criterion = nn.CrossEntropyLoss()
opt = optim.SGD(model.parameters(),lr=0.2)

device = torch.device('cuda:0') if torch.cuda.is_available() else torch.device('cpu')

device

model.to(device)

"""# **Treino**"""

epochs = 15

# 1h e 27mins de processamento
for epoch in range(epochs):
    model.train()
    lloss = []
    for x,y in dl_train:
        x = x.to(device)
        y = y.to(device)
        pred = model(x)
        closs = criterion(pred,y)
        closs.backward()
        opt.step()
        opt.zero_grad()
        lloss.append(closs.item())
        #print(closs.item())
    print("epoch %d media %4.3f"%(epoch,np.mean(lloss)))

"""# **Teste e Avaliação**"""

import sklearn.metrics as metrics
from sklearn.metrics import classification_report

# 17mins de processamento
model.eval()
lres = []
ytrue = []
with torch.no_grad():
    for data,target in dl_test:
        data = data.to(device)
        pred = model(data)
        res  = pred.argmax(dim=1).cpu().tolist()
        lres += res
        ytrue += target

target_names = ['Covid', 'Normal', 'Opacidade', 'Viral']
print("Modelo A -  Mobilenet V3 Small")
print("\n")
print(classification_report(ytrue, lres, target_names=target_names))
matriz_conf = metrics.confusion_matrix(ytrue,lres)
print("Matriz Confusa: \n", matriz_conf)

"""# **Gráficos**"""

import matplotlib.pyplot as plt
  
x = [0,1,2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
y = [1.750, 0.602, 0.471, 0.410, 0.336, 0.293, 0.292, 0.238, 0.212, 0.215, 0.173, 0.149, 0.116, 0.116, 0.102]

plt.plot(x, y)
  
plt.xlabel('x - Epoch')
plt.ylabel('y - Media de Loss')
plt.title('Loss x Epoch')

plt.show()

